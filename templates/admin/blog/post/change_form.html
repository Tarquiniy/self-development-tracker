{% extends "admin/base_site.html" %}
{% load i18n static admin_urls %}

{# Форма редактирования поста — CKEditor5 (Classic) + media-library hook #}
{% block title %}{% if is_popup %}{% trans 'Изменить элемент' %}{% else %}{% trans 'Редактировать пост' %}{% endif %}{% endblock %}

{% block extrahead %}
  {{ block.super }}
  {{ adminform.media }} {# Если какие-то виджеты добавляют свои ассеты, подключаем их #}

  {# CKEditor5 Classic build (CDN). Если у тебя запрещён CDN — скажи, соберу локально. #}
  <script src="https://cdn.ckeditor.com/ckeditor5/39.0.1/classic/ckeditor.js"></script>

  <style>
    .ck-editor__editable_inline { min-height: 260px; background: #fff; color: #111; border-radius:6px; padding:12px; }
    .editor-wrapper { margin: 8px 0 16px 0; }
    .media-button { margin-left: .5rem; }
    .preview-article { padding: 24px; max-width: 900px; margin: 0 auto; }
  </style>
{% endblock %}

{% block content %}
  <div class="change-form">
    <div class="form-header">
      <h1>{{ original|default:_('Новый пост') }}</h1>
      <div class="form-actions">
        <button type="button" class="btn" id="preview-btn">Предпросмотр</button>
        <a class="btn btn-ghost" href="{% url 'admin:blog_post_changelist' %}">Отмена</a>
        <a href="{% url 'admin-media-library' %}" class="btn btn-ghost media-button" id="open-media-lib" onclick="return openMediaLibrary(event)">Медиатека</a>
      </div>
    </div>

    <form method="post" enctype="multipart/form-data" novalidate class="nice-form">{% csrf_token %}
      <div class="form-grid">
        <div class="panel main-panel">
          {% for fieldset in adminform %}
            <fieldset class="fieldset">
              {% if fieldset.name %}<legend>{{ fieldset.name }}</legend>{% endif %}
              <div class="fieldset-grid">
                {% for line in fieldset %}
                  <div class="form-row">{{ line }}</div>
                {% endfor %}
              </div>
            </fieldset>
          {% endfor %}
        </div>

        <aside class="panel side-panel">
          <div class="meta">
            <h3>Опубликовать</h3>
            {{ adminform.form.publish_status }}
            <div class="field">
              <label>Изображение</label>
              {{ adminform.form.image }}
              <div id="image-preview" class="image-preview"></div>
            </div>
            <div class="field">
              {{ adminform.form.categories }}
            </div>
          </div>
        </aside>
      </div>

      <div class="form-footer">
        <input type="submit" value="Сохранить" class="btn-primary">
        <input type="submit" name="_continue" value="Сохранить и продолжить" class="btn">
        <a class="btn btn-ghost" href="{% url 'admin:blog_post_changelist' %}">Вернуться</a>
      </div>
    </form>
  </div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  // Параметры: при необходимости заменяй эти URL на свои в контексте шаблона
  const MEDIA_UPLOAD_URL = "{{ media_upload_url|default:'/api/media/upload/' }}"; // POST file -> { "url": "https://..." }
  const MEDIA_LIST_URL   = "{{ media_list_url|default:'/api/media/list/' }}";   // GET -> [{url, thumb, name}, ...]

  function getCSRF(){
    const el = document.querySelector('input[name="csrfmiddlewaretoken"]');
    return el ? el.value : null;
  }

  // глобальная карта редакторов, доступна для медиапопапа
  window.editorMap = window.editorMap || {};

  const CANDIDATES = ['content', 'short_description', 'body', 'description', 'summary'];

  // UploadAdapter для CKEditor5 — отправляет файл на MEDIA_UPLOAD_URL и ждёт { url }
  class SupabaseUploadAdapter {
    constructor(loader){ this.loader = loader; }
    upload(){
      return this.loader.file.then(file => new Promise((resolve, reject) => {
        const fd = new FormData();
        fd.append('file', file);
        fetch(MEDIA_UPLOAD_URL, {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'X-CSRFToken': getCSRF() || '' },
          body: fd
        }).then(async res => {
          if(!res.ok){
            const t = await res.text().catch(()=>res.statusText);
            reject(t || 'Upload failed');
            return;
          }
          const json = await res.json();
          if(json && json.url){
            resolve({ default: json.url });
          } else {
            reject('Invalid upload response');
          }
        }).catch(err => reject(err.message || String(err)));
      }));
    }
    abort(){}
  }

  function SupabaseAdapterPlugin(editor){
    editor.plugins.get('FileRepository').createUploadAdapter = (loader) => {
      return new SupabaseUploadAdapter(loader);
    };
  }

  function initCKEditors(){
    CANDIDATES.forEach(name => {
      const ta = document.querySelector('textarea[name="'+name+'"]');
      if(!ta) return;
      if(window.editorMap[name]) return; // уже инициализирован

      // создаём редактор
      ClassicEditor.create(ta, {
        extraPlugins: [ SupabaseAdapterPlugin ],
        toolbar: [
          'heading','|','bold','italic','underline','strikethrough','|',
          'link','bulletedList','numberedList','blockQuote','|',
          'insertTable','mediaEmbed','imageUpload','|','undo','redo'
        ],
        language: 'ru'
      }).then(editor => {
        window.editorMap[name] = editor;
        // при мосте между popup и opener — сделать глобально доступным имя инстанса
        // (popup будет использовать window.opener.__insertMediaToEditor)
      }).catch(err => {
        console.error('CKEditor init error for', name, err);
      });
    });
  }

  // Инициализировать когда DOM готов и через небольшую задержку (защита от асинхронности админки)
  document.addEventListener('DOMContentLoaded', initCKEditors);
  setTimeout(initCKEditors, 600);

  // Функция, которую должен вызывать popup медиатеки: window.opener.__insertMediaToEditor(url [, preferField])
  window.__insertMediaToEditor = function(url, preferField){
    try {
      preferField = preferField || 'content';
      if(window.editorMap && window.editorMap[preferField]){
        const ed = window.editorMap[preferField];
        ed.model.change(writer => {
          const imageElement = writer.createElement('image', { src: url });
          ed.model.insertContent(imageElement, ed.model.document.selection);
        });
        return true;
      }
      // Иначе вставляем в первый доступный редактор
      for(const k in window.editorMap){
        const ed = window.editorMap[k];
        if(ed){
          ed.model.change(writer => {
            const imageElement = writer.createElement('image', { src: url });
            ed.model.insertContent(imageElement, ed.model.document.selection);
          });
          return true;
        }
      }
      // fallback в textarea
      const ta = document.querySelector('textarea[name="'+preferField+'"]') || document.querySelector('textarea');
      if(ta){ ta.value = (ta.value || '') + "\\n<img src='" + url + "' alt=''/>\\n"; return true; }
    } catch(e){ console.warn('insertMediaToEditor failed', e); }
    return false;
  };

  // Открыть медиабиблиотеку в popup (твой маршрут admin-media-library)
  window.openMediaLibrary = function(e){
    try {
      if(e && e.preventDefault) e.preventDefault();
      const url = "{% url 'admin-media-library' %}";
      window.open(url, "media_library", "width=1000,height=700,scrollbars=yes");
    } catch(err){
      console.error('openMediaLibrary error', err);
      alert("{% trans 'Не удалось открыть медиа библиотеку' %}");
    }
    return false;
  };

  // Предпросмотр: собираем данные из редакторов и показываем в новом окне
  const previewBtn = document.getElementById('preview-btn');
  if(previewBtn){
    previewBtn.addEventListener('click', function(){
      const form = document.querySelector('form.nice-form');
      if(!form) return;
      const title = (form.querySelector('[name=title]') || {}).value || '';
      let content = '';
      if(window.editorMap['content']) content = window.editorMap['content'].getData();
      else { const t = form.querySelector('textarea[name="content"]'); content = t ? t.value : ''; }
      let short = '';
      if(window.editorMap['short_description']) short = window.editorMap['short_description'].getData();
      else { const s = form.querySelector('textarea[name="short_description"]'); short = s ? s.value : ''; }

      const w = window.open('', '_blank');
      const html = `
        <!doctype html>
        <html><head><meta charset="utf-8"><title>Предпросмотр — ${escapeHtml(title)}</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link rel="stylesheet" href="{% static 'admin/css/main.css' %}">
        </head><body><article class="container preview-article">
        <h1>${escapeHtml(title)}</h1>
        <section class="preview-short">${short}</section>
        <section class="preview-content">${content}</section>
        </article></body></html>`;
      w.document.open(); w.document.write(html); w.document.close();
    });
  }

  function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

  // Синхронизация содержимого редакторов в textarea перед submit (чтобы Django получил актуальные html)
  document.addEventListener('submit', function(e){
    const form = e.target;
    if(!(form && form.matches && form.matches('form.nice-form'))) return;
    try {
      for(const name of CANDIDATES){
        if(window.editorMap[name]){
          const ta = form.querySelector('textarea[name="'+name+'"]');
          if(ta){ ta.value = window.editorMap[name].getData(); }
        }
      }
    } catch(err){ console.warn('sync editors before submit failed', err); }
  }, true);

})();
</script>
{% endblock %}
